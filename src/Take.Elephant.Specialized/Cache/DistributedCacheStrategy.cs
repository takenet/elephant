using System;
using System.Threading;
using System.Threading.Tasks;

namespace Take.Elephant.Specialized.Cache
{
    /// <summary>
    /// Defines a strategy for synchronization of map cache instances using a bus for providing notifications about changes.
    /// </summary>
    internal sealed class DistributedCacheStrategy<TKey, TValue> : IAsyncDisposable
    {
        private readonly IMap<TKey, TValue> _cache;
        private readonly IBus<string, SynchronizationEvent<TKey>> _synchronizationBus;
        private readonly string _synchronizationChannel;
        private readonly Task _subscriptionTask;
        private readonly Guid _instance;

        public DistributedCacheStrategy(IMap<TKey, TValue> cache, IBus<string, SynchronizationEvent<TKey>> synchronizationBus, string synchronizationChannel)
        {
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _synchronizationBus = synchronizationBus ?? throw new ArgumentNullException(nameof(synchronizationBus));
            _synchronizationChannel = synchronizationChannel ?? throw new ArgumentNullException(nameof(synchronizationChannel));
            _instance = Guid.NewGuid();
            _subscriptionTask = _synchronizationBus.SubscribeAsync(_synchronizationChannel, HandleEventAsync, CancellationToken.None);
        }
        
        internal async Task PublishEventAsync(TKey key, CancellationToken cancellationToken = default)
        {
            await EnsureSubscribedAsync(cancellationToken);
            
            await _synchronizationBus.PublishAsync(
                _synchronizationChannel,
                new SynchronizationEvent<TKey>()
                {
                    Key = key,
                    Instance = _instance
                },
                cancellationToken);
        }
        
        private async Task HandleEventAsync(string synchronizationChannel, SynchronizationEvent<TKey> @event, CancellationToken cancellationToken)
        {
            // Ignore events generated by the current instance.
            if (@event.Instance == _instance) return;

            // Remove from the cache either if it is a new key (which will force the value to be reloaded from the source) or if it was removed. 
            await _cache.TryRemoveAsync(@event.Key, cancellationToken);
        }

        private async Task EnsureSubscribedAsync(CancellationToken cancellationToken)
        {
            if (!_subscriptionTask.IsCompleted)
            {
                var tcs = new TaskCompletionSource<object>();
                await using var _ = cancellationToken.Register(() => tcs.TrySetCanceled(cancellationToken));
                await Task.WhenAny(_subscriptionTask, tcs.Task);
                cancellationToken.ThrowIfCancellationRequested();
            }
        }

        public async ValueTask DisposeAsync()
        {
            try
            {
                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
                await _synchronizationBus.UnsubscribeAsync(_synchronizationChannel, cts.Token).ConfigureAwait(false);
            }
            catch (OperationCanceledException) { }
        }
    }
}